<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Hash Checker</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #0f1115;
            color: #fff;
            margin: 0;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #4cc9f0;
        }

        .inputs {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }

        textarea {
            flex: 1;
            padding: 10px;
            font-size: 14px;
            border-radius: 8px;
            border: none;
            resize: vertical;
            background: #1a1d23;
            color: #fff;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
        }

        .card {
            background: #1a1d23;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #2a2e36;
            word-break: break-all;
        }

        .card h3 {
            margin: 0 0 10px;
            color: #4cc9f0;
            font-size: 16px;
        }

        .match {
            border: 2px solid #4caf50;
            background: #102915;
        }

        /* small monospace for hash text */
        .card div.hash {
            font-family: "Courier New", monospace;
            font-size: 13px;
            color: #dfe7eb;
            white-space: pre-wrap;
        }
    </style>
</head>

<body>
    <h1>Hash Checker</h1>

    <div class="inputs">
        <textarea id="inputText" rows="4" placeholder="Enter text to hash..."></textarea>
        <textarea id="compareText" rows="4" placeholder="Paste hash to compare..."></textarea>
    </div>

    <div class="grid" id="results"></div>

    <!-- External libs: MD2/MD4 from Browserling, CryptoJS, js-sha3, blakejs, md6 -->
    <script src="https://www.browserling.com/js/tools/md2.js"></script>
    <script src="https://www.browserling.com/js/tools/md4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha3/0.9.2/sha3.min.js"></script>
    <!-- Load MD6 from the specified URL -->
    <script src="https://www.browserling.com/js/tools/md6.js"></script>
    <!-- blakejs: include both blake2s & blake2b builds -->
    <script src="https://cdn.jsdelivr.net/npm/blakejs@1.2.1/blake2s.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/blakejs@1.2.1/blake2b.min.js"></script>

    <script>
        // List of algorithms (keeps your original ordering)
        const algorithms = [
            "MD2", "MD4", "MD5", "MD6",
            "SHA-1", "SHA-224", "SHA-256", "SHA-384", "SHA-512",
            "SHA3-224", "SHA3-256", "SHA3-384", "SHA3-512",
            "BLAKE2s", "BLAKE2b",
            "RIPEMD-160",
            "Base64 Encode", "Base64 Decode",
            "CRC32", "Entropy"
        ];

        const resultsDiv = document.getElementById("results");

        function createCards() {
            resultsDiv.innerHTML = "";
            algorithms.forEach(alg => {
                const card = document.createElement("div");
                card.className = "card";
                const inner = document.createElement("div");
                inner.innerHTML = `<h3>${alg}</h3><div id="hash-${alg}" class="hash">Not implemented yet</div>`;
                card.appendChild(inner);
                resultsDiv.appendChild(card);
            });
        }

        createCards();

        // Helper: WebCrypto digest for supported algorithms (SHA-1/256/384/512)
        async function webcryptoHex(alg, message) {
            try {
                const msgBuffer = new TextEncoder().encode(message);
                const hashBuffer = await crypto.subtle.digest(alg, msgBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
            } catch (e) {
                return "Not supported";
            }
        }

        // CRC32 implementation
        function crc32(str) {
            let crc = 0 ^ (-1);
            for (let i = 0; i < str.length; i++) {
                crc = (crc >>> 8) ^ crc32Table[(crc ^ str.charCodeAt(i)) & 0xFF];
            }
            return ((crc ^ (-1)) >>> 0).toString(16).padStart(8, "0");
        }
        const crc32Table = (() => {
            let c, table = [];
            for (let n = 0; n < 256; n++) {
                c = n;
                for (let k = 0; k < 8; k++) {
                    c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                }
                table[n] = c;
            }
            return table;
        })();

        // Entropy (Shannon)
        function entropy(str) {
            if (!str || str.length === 0) return "0.0000";
            const freq = {};
            for (let c of str) freq[c] = (freq[c] || 0) + 1;
            const len = str.length;
            let ent = 0;
            for (let c in freq) {
                let p = freq[c] / len;
                ent -= p * Math.log2(p);
            }
            return ent.toFixed(4);
        }

        // Normalize function to ensure hex lower-case (and sensible fallback string)
        function normalizeHex(v) {
            if (typeof v !== "string") return String(v);
            return v.trim().toLowerCase();
        }

        // MD6 hash function using the loaded library
        function md6Hash(text, size = 256) {
            try {
                // Check if md6hash library is loaded
                if (typeof md6hash === 'function') {
                    const md6 = new md6hash();
                    return md6.hex(text, size);
                } else {
                    return "MD6 library not loaded";
                }
            } catch (e) {
                return "MD6 error: " + e.message;
            }
        }

        async function updateHashes() {
            const text = document.getElementById("inputText").value;
            const compare = document.getElementById("compareText").value.trim().toLowerCase();

            // compute values for all algorithms in parallel where possible
            // We'll build a map of algorithm -> value
            const values = {};

            // MD2 (Browserling defines md2(str) -> hex) — check existence
            try {
                values["MD2"] = (typeof md2 === "function") ? normalizeHex(md2(text)) : "Not supported";
            } catch (e) { values["MD2"] = "Not supported"; }

            // MD4 (Browserling defines md4(str) -> hex)
            try {
                values["MD4"] = (typeof md4 === "function") ? normalizeHex(md4(text)) : "Not supported";
            } catch (e) { values["MD4"] = "Not supported"; }

            // MD5 via CryptoJS
            try {
                values["MD5"] = (typeof CryptoJS !== "undefined") ? normalizeHex(CryptoJS.MD5(text).toString()) : "Not supported";
            } catch (e) { values["MD5"] = "Not supported"; }

            // MD6 using the loaded library
            try {
                values["MD6"] = md6Hash(text, 256);
            } catch (e) { values["MD6"] = "Not supported"; }

            // SHA-1, SHA-256, SHA-384, SHA-512 via WebCrypto
            values["SHA-1"] = await webcryptoHex("SHA-1", text).then(normalizeHex).catch(() => "Not supported");
            // SHA-224 not in WebCrypto reliably — fallback to CryptoJS
            try {
                values["SHA-224"] = (typeof CryptoJS !== "undefined") ? normalizeHex(CryptoJS.SHA224(text).toString()) : "Not supported";
            } catch (e) { values["SHA-224"] = "Not supported"; }
            values["SHA-256"] = await webcryptoHex("SHA-256", text).then(normalizeHex).catch(() => "Not supported");
            values["SHA-384"] = await webcryptoHex("SHA-384", text).then(normalizeHex).catch(() => "Not supported");
            values["SHA-512"] = await webcryptoHex("SHA-512", text).then(normalizeHex).catch(() => "Not supported");

            // SHA3 variants: prefer js-sha3 functions if available, otherwise CryptoJS.SHA3
            try {
                if (typeof sha3_224 === "function") {
                    values["SHA3-224"] = normalizeHex(sha3_224(text));
                    values["SHA3-256"] = normalizeHex(sha3_256(text));
                    values["SHA3-384"] = normalizeHex(sha3_384(text));
                    values["SHA3-512"] = normalizeHex(sha3_512(text));
                } else if (typeof CryptoJS !== "undefined") {
                    values["SHA3-224"] = normalizeHex(CryptoJS.SHA3(text, { outputLength: 224 }).toString());
                    values["SHA3-256"] = normalizeHex(CryptoJS.SHA3(text, { outputLength: 256 }).toString());
                    values["SHA3-384"] = normalizeHex(CryptoJS.SHA3(text, { outputLength: 384 }).toString());
                    values["SHA3-512"] = normalizeHex(CryptoJS.SHA3(text, { outputLength: 512 }).toString());
                } else {
                    values["SHA3-224"] = values["SHA3-256"] = values["SHA3-384"] = values["SHA3-512"] = "Not supported";
                }
            } catch (e) {
                values["SHA3-224"] = values["SHA3-256"] = values["SHA3-384"] = values["SHA3-512"] = "Not supported";
            }

            // BLAKE2s / BLAKE2b via blakejs (exposes blake2sHex / blake2bHex)
            try {
                if (typeof blakejs !== "undefined") {
                    // some blakejs builds expose blake2sHex/blake2bHex on global 'blakejs'
                    if (typeof blakejs.blake2sHex === "function") values["BLAKE2s"] = normalizeHex(blakejs.blake2sHex(text));
                    else if (typeof blake2sHex === "function") values["BLAKE2s"] = normalizeHex(blake2sHex(text));
                    else values["BLAKE2s"] = "Not supported";

                    if (typeof blakejs.blake2bHex === "function") values["BLAKE2b"] = normalizeHex(blakejs.blake2bHex(text));
                    else if (typeof blake2bHex === "function") values["BLAKE2b"] = normalizeHex(blake2bHex(text));
                    else values["BLAKE2b"] = "Not supported";
                } else {
                    // some builds put blake2s/blake2b functions directly global
                    if (typeof blake2sHex === "function") values["BLAKE2s"] = normalizeHex(blake2sHex(text));
                    else values["BLAKE2s"] = "Not supported";
                    if (typeof blake2bHex === "function") values["BLAKE2b"] = normalizeHex(blake2bHex(text));
                    else values["BLAKE2b"] = "Not supported";
                }
            } catch (e) {
                values["BLAKE2s"] = values["BLAKE2b"] = "Not supported";
            }

            // RIPEMD-160 via CryptoJS
            try {
                values["RIPEMD-160"] = (typeof CryptoJS !== "undefined") ? normalizeHex(CryptoJS.RIPEMD160(text).toString()) : "Not supported";
            } catch (e) {
                values["RIPEMD-160"] = "Not supported";
            }

            // Base64 encode/decode
            try { values["Base64 Encode"] = btoa(text); } catch (e) { values["Base64 Encode"] = "Not supported"; }
            try { values["Base64 Decode"] = atob(text); } catch (e) { values["Base64 Decode"] = "Invalid Base64"; }

            // CRC32 & Entropy
            try { values["CRC32"] = crc32(text); } catch (e) { values["CRC32"] = "Not supported"; }
            values["Entropy"] = entropy(text);

            // Now update the UI cards
            for (const alg of algorithms) {
                const div = document.getElementById("hash-" + alg);
                const v = (alg in values) ? values[alg] : "Not supported";
                div.innerText = v;
                // compare highlight: exact match (lowercased)
                const isMatch = compare && typeof v === "string" && v.toLowerCase() === compare;
                div.parentElement.classList.toggle("match", isMatch);
            }
        }

        // wire events
        document.getElementById("inputText").addEventListener("input", updateHashes);
        document.getElementById("compareText").addEventListener("input", updateHashes);

        // initial run (empty)
        updateHashes();
    </script>
</body>

</html>